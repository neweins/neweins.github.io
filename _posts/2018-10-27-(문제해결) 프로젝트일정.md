---

layout: post
title: [문제해결] 제품배치

description: >
개발실의 개수와 면적에 따라
필요한 제품을 할당하는 작업을 진행하려고 한다.
도면을 분석하여 총 개발실의 개수와
가장 넓은 개발실의 면적을 구하는 프로그램을 구현하라.


tags: [neweins]

---

# [문제해결] 제품 배치

## [요구사항]

개발실 전체의 도면 정보
1. 크기는 H * W이며, H는 세로 크기이고 W는 가로 크기 (1≤H,W≤50)
2. 개발실은 1*1 크기의 격자로 구성
3. 도면은 아래 그림과 같으며, 굵은 선은 벽, 점선은 통로
4. 도면의 가장자리는 항상 벽이며, 벽으로 둘러싸이면 개별 개발실임

![](/assets/img/deploy_1.jpg)  ![](/assets/img/deploy_3.jpg)
          

1. 벽 정보는 벽이 있는 방향에 해당하는 수를 더한 값이 주어진다.
   (이진수의 각 비트를 연상해도 됨)
2. 서: 1, 북: 2, 동: 4, 남: 8
   - 네 방향이 모두 막혀있는 경우: 15
   - 서, 북, 남 방향이 막혀있는 경우: 11
3. 입력 예로 주어진 도면은 아래와 같다

![](/assets/img/deploy_2.jpg)

입력 예는 아래 그림과 같이 개발실의 개수는 5개이고,
가장 넓은 개발실은 1번으로 넓이는 9이다. (격자의 개수가 넓이)
(아래그림에서 개발실 번호는 좌측상단부터 순서대로 부여)

![](/assets/img/deploy_4.jpg)


개발실 전체의 도면이 주어질 때,
개발실의 개수와 가장 넓은 개발실의 넓이를 구하는 프로그램을 구현하라.

## [입력형식]

첫 번째 줄에는 H(세로크기)가 입력된다. (1≤H≤50)
두 번째 줄에는 W(가로크기)가 입력된다. (1≤W≤50)
세 번째 줄부터 H줄에 걸쳐 W개의 정수가 공백으로 구분되어 입력된다.
각 정수는 각 격자의 벽 정보이다. (0≤정수≤15)


## [출력 형식]

첫 번째 줄에 개발실의 개수를 출력한다.
두 번째 줄에는 가장 넓은 개발실의 넓이를 출력한다.

## 힌트
queue 자료구조와 
벽(wall)의 방향에 대해 재정의된 배열 자료 구조 dir[16][4]
방문 유무를 확인하는 visit[]
숫자를 입력할 checkCnt[]
이를 이용하여 넓이 우선탐색(BFS)기법으로 풀어보자

신도시의 파이프 문제와 접근방법이 완전히 동일한 문제다.
한 칸을 구성하는 벽의 모양에 따라 그 합이 0~15중의 값을 가진다.
좌(서) 우(동) 상(북) 하(남)의 4 방향에 대해 부모 노드(pNode)와 자식 노드(cNode)의 서로 인접한 면에 벽이 있는지(1) 없는지(0) 판별한다. 
시작점이 고정이 아니기 때문에 처음부터 끝까지 하나씩 이동하며 root 노드로 설정하여 탐색해 나간다. 즉 시작점은 완전탐색이지만, visit한 곳이면 skip하여 시간 단축할 수 있다.

~~~
입력
4
7
11 6 11 6 3 10 6
7 9 6 13 5 15 5
1 10 12 7 13 7 5
13 11 10 8 10 12 13

출력
5
9
~~~

~~~
입력
5
10
3 10 10 2 10 10 2 10 10 6
1 6 3 4 3 6 1 6 3 4
1 4 1 4 1 4 1 4 1 4
1 12 9 4 9 12 1 12 9 4
9 10 10 8 10 10 8 10 10 12

출력
2
44
~~~

~~~

입력
7
8
15 15 15 15 15 15 15 15
15 15 15 15 15 15 15 15
15 15 15 15 15 15 15 15
15 15 15 15 15 15 15 15
15 15 15 15 15 15 15 15
15 15 15 15 15 15 15 15
15 15 15 15 15 15 15 15

출력
56
1

~~~

~~~
입력
14
15
11 14 3 6 3 6 3 6 3 6 3 6 11 2 6
3 10 12 9 12 9 12 9 12 9 12 9 6 1 4
13 7 11 10 10 10 10 10 10 14 11 6 5 1 4
11 4 3 10 10 10 10 10 10 10 6 5 13 1 4
7 13 5 7 11 10 2 10 14 7 5 13 7 9 12
1 14 5 1 10 14 5 11 10 4 9 6 1 10 6
13 7 5 5 3 10 8 10 6 5 3 12 9 10 12
11 4 5 13 5 3 10 6 5 13 5 3 10 10 6
7 13 1 10 4 1 10 4 1 10 4 5 3 10 12
1 14 5 7 5 9 10 12 5 7 5 5 9 10 6
13 7 13 5 9 10 2 10 12 13 13 5 3 10 12
7 5 15 9 10 14 5 11 14 11 14 5 9 10 6
5 13 7 7 11 10 8 10 14 7 3 12 3 10 12
13 15 13 13 11 10 14 11 10 12 9 10 8 10 14

출력
27
55

~~~

~~~
입력
20
15
3 2 2 2 2 2 2 2 2 2 2 2 2 2 6
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
9 8 8 8 8 8 8 8 8 8 8 8 8 8 12
3 2 2 2 2 2 2 2 2 2 2 2 2 2 6
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
1 0 0 0 0 0 0 0 0 0 0 0 0 0 4
9 8 8 8 8 8 8 8 8 8 8 8 8 8 12

출력
2
165

~~~

~~~

입력
40
10
3 10 10 10 10 10 10 10 10 6
5 3 10 10 10 10 10 10 6 5
5 5 3 10 10 10 10 6 5 5
5 5 5 3 10 10 6 5 5 5
5 5 5 5 7 7 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5
5 5 5 5 13 13 5 5 5 5
5 5 5 9 10 10 12 5 5 5
5 5 9 10 10 10 10 12 5 5
5 9 10 10 10 10 10 10 12 5
9 10 10 10 10 10 10 10 10 12

출력
6
96

~~~

# 구현

~~~c

#include <iostream>
#include <queue>

using namespace std;

int H;		// 세로 크기
int W;		// 가로 크기
int map[50][50];	//지도

int visit[50][50];
int checkCnt[50][50];

struct ANS{
	int count;	// room 개수
	int area;		// 가장 넓은 room 넓이
};

struct RC{
	int h;
	int w;
};

 // 벽 :1
#define LEFT 0
#define RIGHT 1
#define UP 2
#define DOWN 3
int dir[][4] ={
	{0,0,0,0},//0, 좌우상하
	{1,0,0,0},//1
	{0,0,1,0},//2
	{1,0,1,0},//3
	{0,1,0,0},//4
	{1,1,0,0},//5
	{0,1,1,0},//6
	{1,1,1,0},//7
	{0,0,0,1},//8
	{1,0,0,1},//9
	{0,0,1,1},//10

	{1,0,1,1},//11
	{0,1,0,1},//12
	{1,1,0,1},//13
	{0,1,1,1},//14
	{1,1,1,1},//15
	
};

void InputData(){
	int i, j;
	cin >> H;
	cin >> W;
	for(i=0 ; i<H ; i++){
		for(j=0 ; j<W ; j++){
			cin >> map[i][j];
		}
	}
}

int main(){
	ANS ans = {0, 0};

	InputData();			//	입력 함수

	//	코드를 작성하세요
	//루프로 돌면서 시작점 선택하고 출발
	// 시작점이 visit이면 skip 
	queue<RC> buffer;
	RC Node;
	int cnt=1;
	int maxArea=0;
	int sum=0;
	for(int h=0; h<H; ++h){
		for(int w=0; w<W; ++w){
			if(visit[h][w] ==1) continue;
			
			visit[h][w] =1;
			checkCnt[h][w] = cnt;
			Node.h = h;
			Node.w = w;
			buffer.push(Node);
			
			while(1){
				if(buffer.empty()){
					cnt++;
					break;
				}
				RC pNode = buffer.front();
				buffer.pop();
				
				//좌
				if(pNode.w -1 >=0){
						RC cNode;
						cNode.w = pNode.w-1;
						cNode.h = pNode.h;
					
					if( visit[cNode.h][cNode.w] == 0 &&
						 	(dir[map[pNode.h][pNode.w]][LEFT] == 0 && dir[map[cNode.h][cNode.w]][RIGHT] == 0	)){
					
						visit[cNode.h][cNode.w] =1;
						checkCnt[cNode.h][cNode.w] =cnt;
						buffer.push(cNode);	
						sum++;
					}	
					
					
					
				}
				
				//우
				if(pNode.w +1 <W){
						RC cNode;
						cNode.w = pNode.w+1;
						cNode.h = pNode.h;
					
					if( visit[cNode.h][cNode.w] == 0 &&
						 (dir[map[pNode.h][pNode.w]][RIGHT] == 0 && dir[map[cNode.h][cNode.w]][LEFT] == 0	)){
					
						visit[cNode.h][cNode.w] =1;
						checkCnt[cNode.h][cNode.w] =cnt;
						buffer.push(cNode);				
						sum++;
					}					 
				}			
				
				//상
				if(pNode.h -1 >=0){
						RC cNode;
						cNode.w = pNode.w;
						cNode.h = pNode.h-1;
					
					if( visit[cNode.h][cNode.w] == 0 &&
						 (dir[map[pNode.h][pNode.w]][UP] == 0 && dir[map[cNode.h][cNode.w]][DOWN] == 0	)){
						
						visit[cNode.h][cNode.w] =1;
						checkCnt[cNode.h][cNode.w] =cnt;
						buffer.push(cNode);	
						sum++;
					}					 
				}				
				
				//하
				if(pNode.h +1 < H){
						RC cNode;
						cNode.w = pNode.w;
						cNode.h = pNode.h+1;
					
					if( visit[cNode.h][cNode.w] == 0 &&
						 (dir[map[pNode.h][pNode.w]][DOWN] == 0 && dir[map[cNode.h][cNode.w]][UP] == 0	)){
					
						visit[cNode.h][cNode.w] =1;
						checkCnt[cNode.h][cNode.w] =cnt;
						buffer.push(cNode);		
						sum++;
					}					 
				}				
			}//while()

	// 				for(int h=0; h<H; ++h){
	// 	for(int w=0; w<W; ++w){
	// 		cout<< checkCnt[h][w]<<" ";
	// 	}
	// 			cout << endl;
	// 	}
	// cout << endl;
			if(maxArea < sum) maxArea = sum;
			sum=0;			
		}
	}
	

	
	
	ans.count = cnt-1;
	ans.area = maxArea+1;
	cout << endl << endl;
	cout << ans.count << endl;	//	정답 출력
	cout << ans.area << endl;		//	정답 출력
	return 0;
}



~~~
