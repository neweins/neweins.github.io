---

layout: post
title: (문제해결) 산책
description: >
  직원들의 건강을 위해 점심 식사 후 산책을 하기로 했다.
산책로는 좁기 때문에 다른 사람을 추월할 수 없어서 그룹이 만들어지는데 몇 개의 그룹이 만들어 지는지 알아보려고 한다.

tags: [neweins]

---

# (문제해결) 산책

## [요구사항]

모든 직원이 동시에 출발하고 출발 위치는 직원마다 다르며, 산책 속도는 직원 별로 같거나 다를 수 있다. 산책은 총 T분 동안 진행되는데 산책로가 좁기 때문에 다른 사람을 추월할 수 없어서 그룹이 형성된다.

## 값 범위
1. 직원 수 N은 1 이상 100,000 이하
2. 산책 시간 T는 1 이상 1,000,000,000 분 이하
3. 직원 i번의 출발 위치 Pi는 0 이상 1,000,000,000 이하
4. 직원 i번의 산책 속도 Si는 0 이상 1,000,000,000 이하

산책로가 하나 밖에 없고 좁아서 다른 직원을 추월할 수 없다.
그래서 더 빠른 직원이 다른 직원을 따라 잡았을 때, 추월하지 못하고 같은 속도로 산책할 수 밖에 없다(이때, 직원들이 한 줄로 길게 늘어지게 되지만 그냥 같은 위치에 있는 것으로 취급함, 아래 설명 참조). 즉, 그룹이 만들어 지게 된다.
T분 후에 같은 위치에 있어도 같은 그룹이다.

입력 1에서 5명의 직원이 3분 동안 산책을 하면,
![](/assets/img/산책_1.jpg)
다음 표와 같이 3 그룹이 형성된다.
![](/assets/img/산책_2.jpg)

그룹 1은 0번 직원으로 3위치에 있으며,
그룹 2는 1번 직원으로 7위치에 있고,
그룹 3은 2, 3, 4 번 직원으로 9위치에 있다.
2번 직원은 2 + 3 * 3 = 11 위치까지 갈 수 있지만 앞 직원이 9위치까지만 갈 수 있으므로 같은 그룹이 된다.

직원 수 N과 산책 시간 T, 그리고 각 직원의 출발 위치와 속도가 주어졌을 때,
T분 후에 형성되는 그룹의 수를 계산하시오

## [입력형식]

첫 번째 줄에는 직원의 수 N과 산책시간 T가 공백으로 구분되어 입력
두 번째 줄에는 N줄에 걸쳐 각 직원의 출발 위치 Pi와 산책 속도 Si가 공백으로 구분되어 입력(출발 위치 오름차순으로 입력)

~~~
5 3
0 1
1 2
2 3
3 2
6 1
~~~

## [출력 형식]

T분 후 형성되는 그룹의 수를 출력

~~~
3
~~~



## c++ 구현

~~~c

#include <iostream>
using namespace std;

int N;//직원 수
int T;//산책 시간(분단위)
long long int P[100000 + 10];//직원 출발 위치
long long int S[100000 + 10];//직원 산책 속도(분당)
long long int rPos[100000 + 10]; // 실제위치



void InputData(){
	cin >> N >> T;
	for (int i = 0; i < N; i++){
		cin >> P[i] >> S[i];
		rPos[i] = P[i] + S[i] * T;
	}
}


int solve()
{
	int groupCnt=1;
	for(int i=N-1; i >=1; --i){
		if(rPos[i] < rPos[i-1]){
			rPos[i-1] = rPos[i];
		}
	}
	
	for(int i=0; i<N-1; ++i){
		if(rPos[i] == rPos[i+1]){
		 continue;
		}
		groupCnt++;
	}
	
	return groupCnt;
}

int main(){
	long long int ans = -1;

	InputData();			//	입력 함수

	//	코드를 작성하세요
	ans = solve();
	
	// for(int i=0; i<N; ++i){
	// 	printf("%lld ", rPos[i]);
	// }
	// printf("\n");
	
	cout << ans << endl;	//	정답 출력
	return 0;
}



~~~

