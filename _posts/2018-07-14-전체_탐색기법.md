---
layout: post
title: 탐색 알고리즘
description: >
  문제를 해결하기 위해서 가장 단순하게 쉽게 해를 얻를 수 있어야 하는데 가장 먼저 생각해 볼만한 것이 "무식하게 풀수 있는가?" 이다. 탐색 알고리즘의 출발점은 brute-force, 즉 무식하게 탐색하는 것이다. 일반적으로 컴퓨터는 1초에 약 1억 번의 연산이 가능하다. 그래서 컴퓨터의 빠른 연산 능력을 활용하는 대표적인 방법이다.

tags: [neweins]
---

# 탐색 알고리즘

## 탐색이란?

- 같은 형태의 한 개 이상의 자료들이 모여 있는 집합에서 특정 자료를 찾는 모든 작업
- **`탐색할 자료가 저장되어 있는 구조를 먼저 파악하는 것이 중요`**

> 탐색 구조가 직접적으로 드러난 경우는 쉬운 문제, 직접 드러나지는 않으나 문제 해결과정에서 자체적으로 구조화하며 탐색하는 경우 중급 이상 문제

## 탐색 기반 설계

0. 주어진 문제에서 주어진 데이터를 특성에 맞도록 구조화하고 이 자료를 적절한 방법으로 탐색해 나가면서 원하는 해를 찾는 알고리즘이 필요하다고 동물적 본능이 작동했다면
1. 먼저 전체를 탐색하는 전체 탐색법과 탐색할 영역을 적절한 방법으로 배제하여 탐색의 효율을 높이는 부분 탐색법을 생각해 볼 수 있다.
2. 그리고, 해당 문제에서 **자료구조를 우선 파악** 하고 적절한 탐색 기법을 선택할 수 있는데
3. 자료구조가 눈에 보였다면 최종 알고리즘은 가장 오른쪽에 나열되어 있는 것들 중 하나를 선택할 수 있다.

`아래 이미지를 머리속에 잘담아 두자.`

![](/assets/img/seach.png)


## 전체 탐색 또는 완전탐색(exhaustive search)이란?

- 주어진 문제에서 해가 될 수 있는 **`모든 가능성`** 을 검사하여 해를 구하는 기법
- 장점 : 항상 정확한 해를 구할 수 있다.
- 단점 : 탐색 내용이 많을 경우 많은 시간이 소요될 수 있다.( 부분 탐색법이 이를 보완할 수 있다.)
- brute-force 느낌이 난다.
- 구조에 따라 2가지로 나눌 수 있다.
  - 선형구조의 전체 탐색 : 주로 반복문을 이용하여 탐색 (1차원, 다차원 구조의 탐색)
    - array, linked list
  - 비선형구조의 전체 탐색 : backtracking 기법을 이용한 탐색(backtracking기법은 재귀함수를 주로 이용)
    - tree, graph

> Brute-force search : 가장 간단하고 단순 무식한 탐색이지만 만들기 쉽고 다른 알고리즘을 생각하는 출발점
>> Brute : 짐승, 야수
>> force : 힘, 물리력

## 문제 1
- 배열이 주어졌다. 이것의 최대, 최소값 구하라.

> 어떤 알고리즘을 선택할까? 이것은 이미 자료구조가 주어져 있으므로 난이도는 반은 초급이다.
> 배열이므로 선형구조로 파악되며 이것을 전체탐색할 것인지, 부분 탐색할 것인지 생각해 볼수 있다.
> 먼저 brute-force하게 일일이 모든 가능성을 한땀한땀 짚어보면서 찾아보자.
> 탐색 -> 전체탐색 -> 선형구조 탐색 -> 배열 탐색 -> 순차검색(linear search, sequential search)

1. 최대값은 어떻게 찾아낼까?
- 배열의 0번 index가 최대(최소)라고 가정
- 배열 내에서 최대(최소)값 비교하면서 찾음
- 끝

~~~c
//input		ap : 데이터 저장배열의 주소
//			count : 배열내에 저장되어 잇는 데이터의 개수
//			index : 최대값의 인덱스를 저장할 변수의 시작주소를 받은 포인터 변수
//output	배열내의 최대값/최소값
int checkMAX(int *ap, size_t count, size_t*index)
{
	size_t i;
	int maxIndex = 0;
	for (i = 1; i < count; ++i) {
		if (ap[index] < ap[i]) {
			maxIndex = i;
		}
	}

	*index = maxIndex;
	return ap[maxIndex];
}

int checkMIN(int *ap, size_t count, size_t* index)
{
	size_t i;
	int minIndex = 0;
	for (i = 1; i < count; ++i) {
		if (ap[index] > ap[i]) {
			minIndex = i;
		}
	}

	*index = minIndex;
	return ap[minIndex];
}
~~~
**

## 문제 2
- 주어진 배열에서 단일 검색 및 다중 검색을 구현하라. 단, 단일 검색은 제일 처음 찾은 data만 출력하라.
> 탐색 -> 전체탐색 -> 선형구조 탐색 -> 배열 탐색 -> 순차검색(linear search, sequential search)

![](/assets/img/array_1.png)

~~~
구현 함수 생각해보기
- 순차 검색 함수(단일 검색) : int linearUniqueSearch(int *ap, size_t size, int key)
- 순차 검색 함수(다중 검색) : size_t *linearMultiSearch(int *ap, size_t size, int key, size_t *pcnt)
~~~

**
~~~c

int linearUniqueSearch(int *ap, size_t size, int key)
{
	size_t i;
	int findIndex = -1;
	for (i = 0; i < size; ++i) {
		if (key = ap[i]) {
			findIndex = i;
			break;
		}
	}
	return findIndex;
}

// input	ap : 검색할 데이터 배열의 시작 주소
//			size : 배열내의 데이터 수
//			key : 검색할 데이터
//			pcnt : 검색된 데이터의 개수를 저장한 공간의 시작주소
//output	찾은 index들이 저장된 동적할당 배열의 시작 주소를 리턴
//			실패시 null pointer 리턴
size_t linearMultiSearch(int *ap, size_t size, int key, size_t *pcnt)
{
  // 다중 검색된 인덱스를 저장하는 동적 할당 배열을 가리키는 포인터 변수 선언 : realloc을 쓰기 위해 반드시 NULL로 초기화해야 함.  
	size_t i;
	size_t* pIndex = NULL;

  //찾은 개수 저장 변수를 0으로 초기화
	*pcnt = 0;

  //배열의 데이터를 순차 검색하면서 검색 데이터를 찾았으면 인게스 저장배열의 메모리를 늘려 잡음. 찾은 위치정보를 저장한 후 찾은 개수를 증가시킴
	for (i = 0; i < size; ++i) {
		if (key == ap[i]) {
			pIndex = (size_t*)realloc(pIndex, (*pcnt + 1) * sizeof(size_t));
			pIndex[*pcnt] = i;
			++*pcnt; // *pcnt++ 로 쓰는 위험한 실수를 범하지 말자.
		}
	}

  //찾은 인덱스들을 저장하고 있는 동작 할당 배열의 시작주소 리턴
	return pIndex;
}
~~~
**

## 문제 3
주어진 배열에서 입력 값을 찾아라

#### 여기서 잠깐 이분 검색에 대해 알아보자

- 이분 검색의 배열의 구간을 반씩 나누어 검색해 나가는 기법(divide and conquer)
- 검색할 데이터가 미리 **정렬** 되어 있어야 한다.
- 순차검색 기법에 비해 검색 속도가 빠른 것이 장점

~~~
알고리즘
1. while(검색구간의 크기 > 0)
1-1. 구간의 중간값을 구한다.
1-2. 구간의 중간값이 key값과 같으면 찾은 것이므로 index 리턴
1-3. key값이 중간값보다 크면 오른쪽 구간을 선택하고 1로 돌아감.
1-4. key값이 중간값보다 작으면 왼쪽 구간을 선택하고 1로 돌아감.
2. 구간의 크기가 0이면 찾지 못한 것임
~~~
> 탐색 -> 전체탐색 -> 선형구조 탐색 -> 배열 탐색 -> 이분검색(binary search)

~~~
구현 함수 생각해보기
- 퀵 정렬 함수 : void quickSort(int *ap, int size)
- 이분 검색 함수 (비재귀) : int binarySearch(int *ap, int leftIndex, int rightIndex, int key)
- 이분 검색 함수(재귀) : int rbinarySearch(int *ap, int leftIndex, int rightIndex, int key)
~~~

**
~~~c

//input : ap - 검색할 데이터 배열의 시작 주소
//        leftIndex - 검색 구간의 좌측 인덱스
//        rightIndex - 검색 구간의 우측 인덱스
//        key - 검색할 데이터
//output : 검색 성공시 찾은 숫자의 index / 검색 실패시 -1 리턴

int binarySearch(int *ap, int leftIndex, int rightIndex, int key)
{
	//검색 구간의 0보다 클 동안 반복 (=이 반드시 포함되어야 검색구간 1이 포함된다.)
	while (leftIndex <= rightIndex) {
		//구간의 중간 위치의 값이 찾는 값이면 index 리턴
		if (ap[(leftIndex + rightIndex) / 2] == key) {
			return (leftIndex + rightIndex) / 2;
		}
		//key값이 중간값보다 크면 오른쪽 구간을 선택하고 다시 반복
		else if (ap[(leftIndex + rightIndex) / 2] < key) {
			leftIndex = (leftIndex + rightIndex) / 2 + 1;

		}
		//key값이 중간값보다 작으면 왼쪽 구간을 선택하고 다시 반복
		else if (ap[(leftIndex + rightIndex) / 2] > key) {
			rightIndex = (leftIndex + rightIndex) / 2 - 1;
		}
	}
	return -1;
}

~~~
**

**중요**
테스트시에는 배열 중 처음값과 중간값, 마지막값, 그리고 없는 값을 key로 입력시켜봤을 때 문제없어야 한다.


~~~c

int rbinarySearch(int *ap, int leftIndex, int rightIndex, int key)
{
  // 구간이 0미만이면 못 찾은 것으로 -1 return
  if(leftIndex > rightIndex){
    return -1;
  }

  //구간의 중간값이 key 값이면 index 리턴(base )
  if( ap[(leftIndex+rightIndex)/2] == key){
    return (leftIndex+rightIndex)/2;
  }
  // key값이 중간값보다 크면 오른쪽 구간을 선택하여 재귀 호출
  else(leftIndex+rightIndex)/2 < key){
    return rbinarySearch(ap, leftIndex+rightIndex)/2 +1, rightIndex, key);//return을 붙여야 한다.
  }  
  // key값이 중간값보다 작으면 왼쪽 구간을 선택하여 재귀 호출
  else{
    return rbinarySearch(ap, leftIndex, leftIndex+rightIndex)/2 - 1, key);//return을 붙여야 한다.
  }
}
~~~


## 문제 4

n개로 이루어진 정수 집합(배열)에서 key값 보다 크거나 같은 수의 첫 위치를 찾고(upper bound)key 값 보다 큰수의 첫위치를 찾아라(greater than)
(단, 입력되는 집합은 오름차순으로 정렬되어 있으며, 같은 수가 여러 개 존재할 수 있다)
반복수행하고 문자 입력되는 종료한다.

|인덱스 | 1|2|3|4|5|6|7|8|9|10|11|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|데이터|3|5|7|7|7|12|15|15|20|30|40|

#### upperBound 검색 테스트를 해보자
입력:1
1번째
입력:3
1번째
입력:10
6번째
입력:15
7번째
입력:50
12번째

~~~c

//input   ap: 검색할 데이터 배열의 시작 주소
//        size: 배열내의 데이터 수
//        key: 검사할 데이터
//output  key값보다 크거나 같은 수가 처음으로 나타나는 위치를 리턴

int upperBound(int* ap, size_t size, int key)
{
  int mid;
  int start =0; // start는 0번으로 초기화
  int end = size; //배열내의 데이터 범위 밖의 위치를 지정하기 위해서 반드시 size-1이 아닌 size로 초기화

  while(end != start){  // start와 end가 같지 않을 동안 반복
    mid = (start + end)/2; //중간 위치 계산
    if(ap[mid] < key) // 중간 값이 key값 보다 작으면 start 위치 조정
    {
      start = mid + 1;
    }
    else{    // 중간 값이 key값 보다 크거나 같으면 end 위치 조정
      end = mid;
    }
  }
  return end + 1; // 찾은 위치 리턴 (start +1도 가능)
}

~~~


#### greaterThan 검색 테스트를 해보자
입력:1
1번째
입력:5
3번째
입력:10
6번째
입력:50
12번째

## 문제 5

화단 둘레의 길이를 입력 받아 삼각형 모양의 화단을 만들려고 한다. 둘레 길이에 맞게 만들 수 있는 서로 다른 화단의 수를 구하는 프로그램을 작성하라.
(화단의 길이 n은 자연수이고 1~100까지의 범위를 갖는다.)

> 다차원 선형 구조의 탑색 기법을 응용한다.
> 삼각형의 성질
>> a, b, c 변이 주어지면
>> a+b > c
>> a<=b<=c
>> a+b+c = around

~~~
<입출력 예시>
입력: 8
(2 3 3)
종류갯수 : 1
입력: 9
(1 4 4) (2 3 4) (3 3 3)
종류갯수 : 3
입력: 10
(2 4 4) (3 3 4)
종류갯수 : 2
입력: 11
(1 5 5) (2 4 5) (3 3 5) (3 4 4)
종류갯수 : 4
입력: 4
없다.
종류갯수 : 0
~~~

~~~c

// solve() - 화단 둘레에 맞는 경우를 출력하고 경우의 수를 리턴
// parameter  around - 화단 둘레의 길이
// returns    둘레 길이에 맞게 만들 수 있는 서로 다른 화단의 수

int solve(int around)
{
	int a, b, c;
	int count = 0;
	for (a = 1; a <= around - a; ++a) {
		for (b = 1; b <= around - a - b; ++b) {
			for (c = 1; c <= around - a - b; ++c) {
				if (a + b + c == around && a <= b && b <= c && a + b > c) {
					++count;
					printf("(%d %d %d) ", a, b, c);
				}
			}
		}
	}

	return count;
}

다른 구현
int solve(int around)
{
	int a, b, c;
  int count=0;
	for (a = 1; a <= around; ++a) {
		for (b = 1; b <= around; ++b) {
			for (c = 1; c <= around; ++c) {
				if (a + b + c == around && a <= b && b <= c && a + b > c ) {
					printf("(%d %d %d) ", a, b, c);
          count++;
				}
			}
		}
	}

	return count;
}

다른 구현
int solve(int around)
{
	int a, b, c;
	int count = 0;
	for (a = 1; a <= around; ++a) {
		for (b = a; b <= around; ++b) {
			for (c = b; c <= around; ++c) {
				if (a + b + c == around && a + b > c) {
					printf("(%d %d %d) ", a, b, c);
					count++;
				}
			}
		}
	}
	return count;
}

다른 구현
int solve(int around)
{
	int a, b, c;
  int count=0;
	for (a = 1; a <= around - a; ++a) {
		for (b = a; b <= around - a - b; ++b) {
			for (c = b; c < a + b; ++c) {
				if (a + b + c == around ) {
					printf("(%d %d %d) ", a, b, c);
          count++;
				}
			}
		}
	}

	return count;
}

다른 구현
int solve(int around)
{
	int a, b, c;
	int count = 0;
	for (a = 1; a <= around - a; ++a) {
		for (b = a; b <=(c= around - a - b); ++b) {
			if (a+b>c) {
				count++;
				printf("(%d %d %d) ", a, b, c);
			}
		}
	}
	return count;
}

~~~

## 문제 6

사무실의 냉난방기를 리모컨으로 조작하려고 한다.
리모컨의 온도조절 버튼은 다음과 같이 총 6개가 있다.

- [+1]버튼 : 온도 1도 올리기
- [-1]버튼 : 온도 1도 내리기
- [+5]버튼 : 온도 5도 올리기
- [-5]버튼 : 온도 5도 내리기
- [+10]버튼 : 온도 10도 올리기
- [-10]버튼 : 온도 10도 내리기

![](/assets/img/20180717_214504.png)

현재 온도와 변경하고자 하는 설정온도가 주어지면 이 버튼들을 이용해서 설정온도를 지정해 주고자할 때 **버튼 누름의 최소 횟수** 를 구하시오.

- 예) 현재온도10, 설정온도23: 10->20->25->24->23(버튼누름횟수:4회)
- 예) 현재온도7, 설정온도19: 7->17->18->19(버튼누름횟수:3회)
- 예) 현재온도34, 설정온도19: 34->24->19(버튼누름횟수:2회)

> 분석
> 가장 단순한 방법인 brute-force로 접근해보면, 버튼의 개수 6과 최대 클릭 횟수 res라 가정하면 이에 비례한 계산량 O(6^res^)이 나온다. 즉 res가 40이라고 가정하면 6^40^을 계산하면 계산량이 너무 많아 실행시간이 너무 오래 걸린다. 그래서 계산량을 줄이가 위한 탐색영역을 배제하는 것을 고려해볼 필요가 있다.
>> 예) 현재온도가 설정온도보다 작은 경우 온도를 내릴 필요가 없다.
>> 예) 현재온도가 설정온도보다 큰 경우 온도를 올릴 필요가 없다.


현재 온도가 7이고 설정온도 38도인 경우를 다음 tree로 생각해보자.

- root
현재 온도(7)가 설정온도가 낮으므로 현재 온도보다 낮은 온도로 설정할 필요없다. 그러므로, -10 -5, -1은 수행하지 않는다.
- 1-layer
현재 온도(17, 12, 8)가 설정 온도보다 낮으므로 현재 온도보다 낮은 온도로 설정 필요없다.
- 2-layer
현재온도(27,25,18)가 역시 설정 온도보다 낮으므로 현재 온도보다 낮은 온도로 설정 필요없다.
- 3-layer
현재온도(37,32,28)가 역시 설정 온도보다 낮으므로 현재 온도보다 낮은 온도로 설정 필요없다.  

![](/assets/img/20180721_091147.png)


~~~c

#include <stdio.h>
#define MAX_CONTROL 40 //온도가 0~40이 이므로 최대 조작횟수가 40을 초과하지 않는다.

int currentTemp; //현재 온도
int settingTemp; //설정 온도

int minControl;//최소 리모컨 조절 횟수
int totCnt = 0;

// temp : 현재온도
// cnt  : 현재까지의 리모컨 조작 횟수
void solve(int temp, int cnt) {
	if (cnt > minControl) return; //basis part 1 : 현재까지의 조작 횟수가 최소 조절 횟수보다 크면 리턴(답이 아니므로 리턴)

	//basis part 2 : 현재 온도가 설정 온도이고 현재까지의 조작 횟수가 최소 횟수보다 작으면 최소 횟수를 현재 조작 횟수로 변경 후 리턴(답이기 때문에 리턴)
	if (temp == settingTemp && cnt < minControl) {
		minControl = cnt;
		return;
	}
	//온도를 바꾸고 조작 횟수를 늘리며 재귀 호출
	if (temp > settingTemp) {
		solve(temp - 5, 1+cnt); //++cnt가 아닌 cnt + 1
		solve(temp - 1, 1+cnt);
		solve(temp - 10, cnt + 1);
	}
	else if (temp < settingTemp) {
		solve(temp + 5, 1+cnt);
		solve(temp + 1, 1+cnt);
		solve(temp + 10, 1 + cnt);
	}

}

int main()
{
	while (1) {
		minControl = MAX_CONTROL;
		printf("current Temp and setting Temp : ");
		if (scanf("%d %d", &currentTemp, &settingTemp) != 2)
			break;
		solve(currentTemp, 0);	// recursive로 구현할 것이기 때문에 global 변수라 하더라도 입력 인자로 사용
		printf("remocon minimum count : %d\n", minControl);
	}

	return 0;
}

~~~
