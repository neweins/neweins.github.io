---

layout: post
title: [문제해결] 단어찾기

description: >
고려시대 목조문화재의
통합 보존시스템 구축연구를 위한 외부 보호 형틀의
최소면적을 계산하는 프로그램을 구현하려고 한다.


tags: [neweins]

---

# [문제해결] 단어찾기

N×M 크기의 표의 각 칸에 알파벳 대문자가 하나씩 써있다. 단어 S가 주어졌을 때, 표에 단어 S가 있는지 없는지 구하는 프로그램을 작성하시오.

단어 S가 표에 존재하려면, 표의 한 칸에서 시작해, 연속해서 그 단어의 모든 알파벳이 순서대로 등장해야 한다. 이때, 연속하는 방향은 위, 아래, 오른쪽, 왼쪽, 대각선 방향 모두 가능하다. 대각선 방향은 왼쪽 위, 오른쪽 아래, 오른쪽 위, 왼쪽 아래 방향이 모두 가능하다. 연속하는 방향이 중간에 바뀌면 안된다.

## 힌트
예제 1의 경우에 ABCD는 아래와 같이 등장한다.
~~~
ACDBE
ABCED
ACCEE
ACHDF
ACBCE
~~~

예제 2의 경우에 STR은 등장한다. STR은 매우 많이 등장하는데, 일부를 아래에 굵게 표시했다.
~~~
STARTS
STRSTR
RRTSRE
SRSTRR
STRTSR
~~~

## 입력
첫째 줄에 길이가 100보다 작거나 같은 단어 S가 주어진다. S는 알파벳 대문자로만 이루어져 있다.

둘째 줄에는 표의 행의 개수 N과 열의 개수 M이 주어진다. N과 M은 100보다 작거나 같은 자연수이다.

셋째 줄부터 N개의 줄에는 표의 각 행에 들어있는 알파벳이 주어진다.

출력
입력으로 주어진 표에 단어 S가 존재하면 1을, 없으면 0을 출력한다.

~~~
예제 입력 1  
ABCD
5 5
ACDBE
ABCED
ACCEE
ACHDF
ACBCE
예제 출력 1  
1
~~~
~~~
예제 입력 2  
STR
6 6
STARTS
STRSTR
RRTSRE
SRSTRR
STRTSR
STSTSS
예제 출력 2  
1
~~~
~~~
예제 입력 3  
AFAFK
2 2
AB
CD
예제 출력 3  
0
~~~
~~~
예제 입력 4  
AAAB
4 4
AAAA
ABBA
ABBA
AAAA
예제 출력 4  
0
~~~

~~~

예제 입력 5
INVITAION
25 25
AAAAAAAAAAAAAAAAAAAAAAAAA
FDSKLFJDSFFLADFHSDFILEWNV
ERHNBDFBULIGHAKSLFGLHFBDS
IFDSJFFFIFFISFSDFISDFSDIF
DSIFSDFIVBDFIAGAGIIGAVADS
INVITAIONDEASONTESTGOOKLU
CKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVAL
DHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVB
KSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTEOOKLU
CKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVAL
DHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVB
KSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOFKLU
CKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVAL
DHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVB
KSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOOKLU
CKFHEKWJFHSDKJFHDSKFSDLFH

예제출력 5
1
~~~

~~~
예제 입력 6
INVITAIONSEASONTESTGOOKLUCW
30 30
IFDSJFFFIFFISFSDFISDFSDIFDSIFS
FDSKLFJDSFFLADFHSDFILEWNVERHND
IFDSJFFFIFFISFSDFISDFSDIFDSIFS
INVITAIONDEASONTESTGOOKLUCKFHE
FDSFJKNVKFWKJFHWHDLHVDVALDHVWR
FDSDSVNSDKVSDKABVKSVBSKVDKVSDK
INVITAIONSEASOUCKFHEKWJFHSDKJF
FDSFJKNVKFWKJFHWHDLHVDUVSDKJFW
FDSDSVNKSVBSKVBKSAVBKSJDDKVSDK
INVITAIONSEAKLUCKFHEKWJFHSDKJF
FDSFJKNVKHVDVALDHVLDSVCVSDKJFW
FDSDSVNSDKVSDKAKSAVBKSJDDKVSDK
INVITAIONSEASLUCKFHEKWJFHSDKJF
FDSFJKNVKFWKJFHWHVLDSVCVSDKJFW
FDSDSVNSDKVSDKABVKVBKSJDDKVSDK
FDSKLFJDSFFLADFHRHNBDFBULIGHAK
IFDSJFFFIFFISFSDSIFSDFIVBDFIAG
INVITAIONSEASOUCKFHEKWJFHSDKJF
FDSFJKNVKFWDVALDHVLDSVCVSDKJFW
FDSDSVNSDKVSKVBKSAVBKSJDDKVSDK
INVITAIONSEAKLUCKFHEKWJFHSDKJF
FDSFJKNVKFWKJFHWHVLDSVCVSDKJFS
FDSDSVNSDKVSDKABVKSVBVKVBKSVBY
INVITAIONSEASONTESTGOOKLUCKFXF
FDSFJKNVKFWKJFHWHDLHVDVALDHJFW
FDSDSVNSDKVSDKABVKSVBIVKVBKSVB
INVITAIONSEASONTESTEKWJFHSDKJF
FDSFJKNVKFWKJFHWHDLHVDCVSDKJFW
FDSDSVNSDKVSDKABVKSVBSKDDKVSDK
FDSKLFJDSFFLADFHSDFBDFBULIGHAK


예제출력 6
1
~~~



~~~
예제 입력 7
INVITAIONSEASONTESTGOOKLUCK
50 50
AAADSFADAAAKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKS
FDSKLFJDSFFLADFHSDFILEWNVERHNBDFBULIGHAKSLFGLHFBDS
IFDSJFFFIFFISFSDFISDFSDIFDSIFSDFIVBDFIAGAGIIGAVADS
INVITAIONDEASONTESTGOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTEOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOFKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
FDSKLFJDSFFLADFHSDFILEWNVERHNBDFBULIGHAKSLFGLHFBDS
IFDSJFFFIFFISFSDFISDFSDIFDSIFSDFIVBDFIAGAGIIGAVADS
INVITAIONSEASONTESTGQOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
INVITAIONSEASONTESTGOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKVBKSAVBKSJDDKVSDKVAVKVBKSVB
FDSKLFJDSFFLADFHSDFILEWNVERHNBDFBULIGHAKSLFGLHFBDS
IFDSJFFFIFFISFSDFISDFSDIFDSIFSDFIVBDFIAGAGIIGAVADS
INVITAIONSEASONTESTGOOKLUCKFHEKWJFHSDKJFHDSKFSDLFH
FDSFJKNVKFWKJFHWHDLHVDVALDHVLDSVCVSDKJFWKJFHDKFHDS
FINVITAIONSEASLUCKFHEKWJFHSDKJSVCVSDKJFWKJFHDKFHDS
FDSFJKNVKFWKJFHWHVLDSVCVSDKJFWSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKVBKSJDDKVSDKSVCVSDKJFWKJFHDKFHDS
FDSKLFJDSFFLADFHRHNBDFBULIGHAKSVCVSDKJFWKJFHDKFHDS
IFDSJFFFIFFISFSDSIFSDFIVBDFIAGSVCVSDKJFWKJFHDKFHDS
INVITAIONSEASOUCKFHEKWJFHSDKJFSVCVSDKJFWKJFHDKFHDS
FDSFJKNVKFWDVALDHVLDSVCVSDKJFWSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSKVBKSAVBKSJDDKVSDKSVCVSDKJFWKJFHDKFHDS
INVITAIONSEAKLUCKFHEKWJFHSDKJFSVCVSDKJFWKJFHDKFHDS
FDSFJKNVKFWKJFHWHVLDSVCVSDKJFSSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBVKVBKSVBYSVCVSDKJFWKJFHDKFHDS
INVITAIONSEASONTESTGOOKLUCKFXFSVCVSDKJFWKJFHDKFHDS
FDSFJKNVKFWKJFHWHDLHVDVALDHJFWSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBIVKVBKSVBSVCVSDKJFWKJFHDKFHDS
INVITAIONSEASONTESTEKWJFHSDKJFSVCVSDKJFWKJFHDKFHDS
FDSFJKNVKFWKJFHWHDLHVDCVSDKJFWSVCVSDKJFWKJFHDKFHDS
FDSDSVNSDKVSDKABVKSVBSKDDKVSDKSVCVSDKJFWKJFHDKFHDS


예제출력 7
1
~~~


# 생각
 모든 좌표를 순차적으로 탐색하는 기초적인 생각을 기반으로 각 문자열의 시작 문자를 발견하면 좌우상하, 대각선 방향으로 각각 문자열 매칭을 수행하였고, 하나라도 발견되면 1을 출력하도록 하였다. 수행 중에 유의할 점은 예외처리인데 범위를 벗어나는 조건을 잘 생각하여야 할듯하다.
아래 코드를 구현해보았다.
그러나 제한 시간이 2초라면 완전탐색은 위험하다.

좀 더 빠른 방법을 생각해보면 첫문자가 발견되는 지점을 root노드라고 생각하면 root 노드로부터 좌,우,상,하, 대각선 연속 방향으로 문자를 비교하면서 root 노드와 동일한 문자가 있으면 해당 좌표값을 queue에 넣어둔다. queue에 꺼낸 해당 좌표를 root node로 두고 각 방향으로 문자열 매칭을 한다. 그리고 이 노드는 visit처리하여 root노드가 되지 않도록한다. queue가 비면 다음 좌표를 탐색한다. 이렇게 해서 첫문자를 root노드로 모두 visit 처리가 될 때까지 반복한다. 그러나 그 사이에 문자열 매칭이 true이면 break하여 1을 출력한다.


~~~c

#include<iostream>
#include <cstring>
#include <string.h>

using namespace std;

int N; //row 1<=N<=100
int M; //col 1<=M<=100
char S[110];
char map[110][100];
char R[110];

bool isOK =false;
int main()
{
    cin >> S;
    cin >> N >> M;
    for(int i=0; i<M; ++i ){
        cin >> map[i];
    }
    int len = (int)strlen(S);
    for(int h=0; h<N; ++h){
        for(int w=0; w<M; ++w){
            if(map[h][w] != S[0]) continue;

            int i=0;
            
            //left
            for(i=0; i<len; ++i){
                if(w-len < 0) break;
                if(S[i] != map[h][w-i]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //right
            for(i=0; i<len; ++i){
                if(w+len > N-1) break;
                if(S[i] != map[h][w+i]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //up
            for(i=0; i<len; ++i){
                if(h-len < 0) break;
                if(S[i] != map[h-i][w]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //down
            for(i=0; i<len; ++i){
                if(h+len > N-1) break;
                if(S[i] != map[h+i][w]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //left and up
            for(i=0; i<len; ++i){
                if(h-len < 0 || w-len < 0) break;
                if(S[i] != map[h-i][w-i]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //left and down
            for(i=0; i<len; ++i){
                if(h+len > N-1 || w-len < 0) break;
                if(S[i] != map[h+i][w-i]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //right and up
            for(i=0; i<len; ++i){
                if(h-len < 0 || w+len > N-1) break;
                if(S[i] != map[h-i][w+i]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
            
            //rignt and down
            for(i=0; i<len; ++i){
                if(h+len > N-1 || w+len > N-1) break;
                if(S[i] != map[h+i][w+i]) break;
            }
            if(i == len){
                isOK = true;
                goto END;
            }
        }
    }
    
END:
    printf("%d ", isOK);
    return 0;
    
}

~~~